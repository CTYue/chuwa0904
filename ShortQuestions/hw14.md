## Testing related:
- 1. Unit Testing: Unit testing is the process of testing individual components or functions in isolation from the rest of the application. The main goal is to ensure that each part of the application behaves as expected independently.
```
import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class CalculatorTest {
    
    @Test
    public void testAdd() {
        // Arrange
        Calculator calculator = new Calculator();
        
        // Act
        int result = calculator.add(2, 3);
        
        // Assert
        assertEquals(5, result);
    }
}

class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
}
```

- 2. Functional Testing: Functional testing evaluates the functionality of the application to ensure it behaves according to the requirements. It involves testing the software against defined specifications without considering internal code structure.
```
import org.junit.Test;
import static org.junit.Assert.assertTrue;

public class LoginTest {
    
    @Test
    public void testLogin() {
        UserService userService = new UserService();
        boolean loginSuccessful = userService.login("user", "password");
        assertTrue(loginSuccessful);
    }
}

class UserService {
    public boolean login(String username, String password) {
        return "user".equals(username) && "password".equals(password);
    }
}

```
- 3. Integration Testing: Integration testing ensures that different components or modules of the software work together as expected. The goal is to find issues related to interactions between modules.
```
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import static org.junit.Assert.assertNotNull;

public class UserServiceIntegrationTest {

    private UserService userService;
    private UserRepository userRepository;

    @Before
    public void setUp() {
        // Mock the repository that interacts with the database
        userRepository = Mockito.mock(UserRepository.class);
        userService = new UserService(userRepository);
    }

    @Test
    public void testFindUserById() {

        Mockito.when(userRepository.findById(1)).thenReturn(new User(1, "John"));

        User user = userService.findUserById(1);

        assertNotNull(user);
        Mockito.verify(userRepository).findById(1); 
    }
}

class UserService {
    private UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public User findUserById(int id) {
        return userRepository.findById(id);
    }
}

interface UserRepository {
    User findById(int id);
}

class User {
    private int id;
    private String name;
    
    public User(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

```
- 4. Regression Testing: Regression testing checks whether new code changes have broken any existing features. It is typically conducted after a change or update to the software.
- 5. Smoke Testing: Smoke testing is a preliminary test to check the basic functionality of the software before moving on to more detailed testing. It ensures that the critical features are working.
- 6. Performance Testing: Performance testing evaluates how well the software performs under certain conditions, such as heavy load, stress, or usage over time.
- 7. A/B Testing: A/B testing involves comparing two versions of a product (A and B) to determine which one performs better based on user behavior.
- 8. User Acceptance TestingUAT is performed by the end-users to verify that the system meets their needs and works as expected. It is the final step before the software goes live.

## 2.Environment related:
1. Development: The development environment is where developers build and test their code locally or in a sandbox environment. This is where the actual writing of code, debugging, and initial testing takes place.
2. QA (Quality Assurance): is used by testers to ensure the software meets the required quality standards. It's typically a separate environment where automated and manual testing are performed. The QA environment mimics production to some extent but may still have some differences, such as using mock services or sanitized test data.
3. Pre-prod/Staging: is a replica of the production environment. It is used for final testing before the software goes live. This environment contains almost identical configurations and databases as production but is used only for testing by internal teams.
4. Production:  is the live environment where the application is available to end-users. It is the most important environment and must be stable, secure, and performant. Changes to this environment must be carefully controlled, typically using Continuous Integration/Continuous Deployment (CI/CD) pipelines.


## 3. Still thinking



