# hw13 Testing

## 2. What is the lifecycle of Junit?

### 1. Setup

This phase puts the the test infrastructure in place. JUnit provides class level setup (`@BeforeAll`) and method level setup (`@BeforeEach`). 

Generally, heavy objects like databse connections are created in class level setup (`@BeforeAll`) while lightweight objects like test objects are reset in the method level setup (`@BeforeEach`).

### 2. Test Execution (`@Test`)

In this phase, the test execution and assertion happen. The execution result will signify a success or failure.

### 3. Cleanup

This phase is used to cleanup the test infrastructure setup in the first phase. Just like setup, cleanup also happen at class level (`@AfterAll`) and method level (`@AfterEach`).

## 3. Explain parameterized testing?

Parameterized testing in JUnit allows you to run the same test with different sets of input data. Instead of writing multiple tests for each input, you write one test that gets executed multiple times with different parameters.

### Key Steps:
1. **Use the `@ParameterizedTest` Annotation**: This replaces the standard `@Test` annotation.
2. **Define Input Sources**: Inputs can be provided via various sources, like `@ValueSource`, `@CsvSource`, or even methods using `@MethodSource`.
3. **Parameterize the Test Method**: The method arguments receive the parameterized inputs for each test execution.

### Example:
```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

public class CalculatorTest {

    @ParameterizedTest
    @ValueSource(ints = {1, 2, 3, 4, 5})
    void testIsEven(int number) {
        assertEquals(0, number % 2);
    }
}
```

## 4. Explain `Mockito` and `PowerMock`.

### 1. `Mockito`
Mockito is a popular Java mocking framework used for unit testing. It allows you to create mock objects and define their behavior in tests, helping isolate the code you are testing by mocking its dependencies.

- **Key Features:**
  - Mock object creation using `Mockito.mock()`.
  - Stubbing: Define how mock methods should behave using `when(...).thenReturn(...)`.
  - Verification: Verify if certain methods were called on mocks using `verify()`.

- **Example:**
  ```java
  List<String> mockedList = Mockito.mock(List.class);
  Mockito.when(mockedList.size()).thenReturn(10);
  assertEquals(10, mockedList.size());
  ```

### 2. `PowerMock`
PowerMock is an extension of Mockito (and other frameworks) that allows mocking of static methods, final classes, private methods, and constructorsâ€”which Mockito alone cannot handle.

- **Key Features:**
    - Mocking static and final methods.
    - Mocking private methods and constructors.
    - Works by extending the capabilities of Mockito, requiring `PowerMockito` class.

- **Example:**
    ```java
    PowerMockito.mockStatic(ClassName.class);
    PowerMockito.when(ClassName.staticMethod()).thenReturn("mockedValue");
    ```

## 5. Compare `@Mock` and `@InjectMock`

In Mockito, `@Mock` and `@InjectMocks` are annotations used for setting up mock objects in unit tests. While both are used for mocking, they serve different purposes and behave differently.

`@Mock` is used to create mock objects for individual classes or interfaces. These mock objects can be used as dependencies in your test class.

`@InjectMocks` is used to automatically inject the mock objects (annotated with `@Mock`) into the class under test. It tries to inject mocks into the constructor, fields, or setter methods of the class.

## 6. Explain `stubbing`.

**Stubbing** in Mockito refers to defining the behavior of a mock object's method when it is called during a test. It allows you to "pre-program" the mock to return specific values or throw exceptions when certain methods are invoked, simulating different scenarios for testing.

## 7. What is Mockito ArgumentMatchers

**ArgumentMatcher** in Mockito are used to define flexible or generalized argument matching when stubbing or verifying methods. Instead of passing specific values, you can use matchers to match a range of possible arguments, allowing for more flexible testing.

## 8. what is Hamcrest Matchers

**Hamcrest** is a popular library in Java used for writing more expressive and flexible test **assertions**. It provides a set of **matchers** that allow for readable and descriptive unit test expressions, improving the clarity of tests. These matchers are typically used to compare actual values against expected values in a flexible way, especially when writing assertions in testing frameworks like JUnit.

```Java
assertThat(value, is(5));
assertThat(value, equalTo(10));
assertThat(value, not(5));
assertThat(value, greaterThan(5));
assertThat(value, lessThan(10));
assertThat("hello world", containsString("world"));
```

## 9. Compare @spy and @Mock?

In Mockito, `@Spy` and `@Mock` are annotations used for creating mock objects, but they serve different purposes and have distinct behaviors. Here's a comparison of the two:

### **`@Mock`**
- **Purpose**: Creates a mock instance of a class or interface. Mocks do not retain any behavior of the actual object.
- **Behavior**: All methods of a mock return default values (e.g., `null`, `0`, `false`) unless explicitly stubbed.
- **Use Case**: Use `@Mock` when you want to test the interactions with a dependency without caring about its actual behavior.

### **`@Spy`**
- **Purpose**: Creates a spy instance of a class, which is a partial mock. A spy retains the original behavior of the object but allows you to stub specific methods.
- **Behavior**: By default, a spy will call the real methods unless they are stubbed. You can also verify the actual interactions.
- **Use Case**: Use `@Spy` when you want to test a class while retaining some of its original behavior.

## 10. Explain Assertion.

An `assertion` is a statement in testing that checks whether a given condition is true, helping to validate the correctness of the code by comparing expected results with actual outcomes.

## 11. in `/Coding/hw13` directory




