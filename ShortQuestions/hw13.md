## HW12
### Question 1
1. Setup:  JUnit provides class level setup (@BeforeAll) and method level setup (@BeforeEach) for setup
   * @BeforeAll: set up expensive resources shared by all tests。
   * @BeforeEach：set up any conditions or initialize variables specific to the individual test case.
2. Test Execution：
   * @BeforeAll：Runs once before all test methods in the current class. It's typically used to set up expensive resources shared by all tests (e.g., starting a database or initializing a test server).
   * @BeforeEach: Runs before each individual test method. It is often used to set up any conditions or initialize variables specific to the individual test case.
   * @Test：The actual test method will annotated with @Test.
3. CleanUp
   * @AfterEach: Runs after each individual test method. It’s used to clean up resources or reset states that were set up in @BeforeEach. For example, closing a file or resetting a mock object.
   * @AfterAll: Runs once after all the tests in the current class are executed. It’s typically used to clean up shared resources created in @BeforeAll.

### Question 2
Parameterized testing in JUnit allows you to run the same test repeatedly with different sets of input data. They are supported through the @ParameterizedTest annotation.
JUnit provides several argument sources to supply input values for parameterized tests. Common ones include:
* @ValueSource: Provides an array of literals (e.g., ints, strings, etc.).
* @CsvSource: Allows you to provide comma-separated values.
* @CsvFileSource: Reads input from a CSV file.
* @MethodSource: Uses a method to supply arguments.
* @EnumSource: Supplies values from an enum type.

### Question 3
Mockito allows developers to create and configure mock objects to simulate the behavior of real objects in order to test specific parts of a system in isolation. Here is some features of Mockito:
* Mocking Objects: Mockito can mock interfaces and classes, so you can simulate their behavior in a test environment.
* Stubbing Methods: You can define how mocked methods should behave when called.
* Verifying Interactions: You can verify whether certain methods were called and with what arguments.
* Mockito supports argument matchers (e.g., any() or eq()) to check method calls with various input arguments.
* Spy: Instead of mocking an object entirely, you can create a "spy," which allows you to call the real methods of an object and stub only specific ones.

PowerMock is an extension to other mocking frameworks, such as Mockito, to provide additional features for cases that are otherwise hard to mock. 
* Mock Static Methods: Mockito cannot mock static methods by default, but PowerMock can.
* Mock Constructors: PowerMock allows you to mock the behavior of object constructors.
* Mock Private Methods: PowerMock can intercept private methods and change their behavior for testing purposes.
* Mock Final Classes and Methods: It can mock final classes and methods, which are usually problematic for standard mocking tools.

### Question 4 
@Mock: It is used to create mock objects for dependencies or other classes that you want to simulate during testing. 
@InjectMocks: It automatically inject the mocked dependencies (annotated with @Mock) into the class that you want to test.
Example code:
```
   @Mock
   private Service mockService; // Mocked dependency

   @InjectMocks
   private MyService myService; // Real object with dependency injected

   @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this); // Initializes mocks and injects them
    }

   @Test
   void testService() {
      when(dependencyService.getData()).thenReturn("Mocked Data");
        
      String result = myService.perform(); // Method of the real object
        
      assertEquals("Mocked Data Processed", result); // Assuming method appends "Processed"
      
   }
```
In this example:
* @Mock creates a mock of DependencyService.
* @InjectMocks creates an instance of **MyService** and automatically injects the mock **mockService** into it. The method **perform()** uses the mock, but the class under test (MyService) itself is not mocked.

### Question 5
Stubbing in unit testing refers to the process of defining the behavior of a mock object's method before it is called in the test.
Control over Dependencies: Stubbing allows you to specify the output or behavior of a method, ensuring consistent results in tests, regardless of the actual implementation.
Isolate the Class Under Test: You focus on testing the logic of the class under test by stubbing external dependencies (e.g., services, databases, external APIs) without needing them to function or even exist.

```
   MyDependency dependency = Mockito.mock(MyDependency.class);

   // Stub a method: When dependency.getData() is called, return "Mocked Data"
   when(dependency.getData()).thenReturn("Mocked Data");
```