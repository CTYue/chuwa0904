
# Annotations Overview (With Questions)

## 1. What new annotations have you learned?
- `@Mock`: Used to create and inject mock objects.
- `@InjectMocks`: Injects mock objects created with `@Mock` into the tested class.
- `@Spy`: Allows partial mocking where real methods can be called.
- `@BeforeAll`: Runs once before all tests to set up necessary resources.
- `@AfterAll`: Runs once after all tests, useful for resource cleanup.
- `@BeforeEach`: Runs before each test method, initializes test data.
- `@AfterEach`: Runs after each test method, usually for cleanup.
- `@ParameterizedTest`: Runs the same test logic with different parameters.

## 2. What is the lifecycle of JUnit?
1. **@BeforeAll**: Executes once before all test methods, often used for setting up static resources.
2. **@BeforeEach**: Runs before each test method, useful for test data setup.
3. **@Test**: The actual test method, executes the logic under test.
4. **@AfterEach**: Runs after each test method, often used for cleaning up test data or resetting conditions.
5. **@AfterAll**: Executes once after all test methods, usually for cleaning up resources.

## 3. Explain parameterized testing?
- Parameterized testing in JUnit allows for running the same test logic with different parameters, avoiding redundancy. It uses the `@ParameterizedTest` annotation and is useful for scenarios where similar logic needs to be tested with varying inputs.

## 4. Explain Mockito and PowerMock.
1. **Mockito**: A Java-based mocking framework used in unit tests to mock dependencies and their behaviors, making it easier to test specific units of code in isolation.
2. **PowerMock**: An extension of Mockito that provides additional capabilities to mock static, final, and private methods, which Mockito alone cannot mock.

## 5. Compare @Mock and @InjectMocks.
- **@Mock**: Creates mock objects for dependencies, allowing test methods to focus only on the logic being tested.
- **@InjectMocks**: Automatically injects mocks into the tested object. It helps in setting up the testing environment with necessary mocks for dependencies.

## 6. What is stubbing?
- Stubbing refers to the process of setting predefined behaviors for methods on mock objects. This is often used to return specific values when certain methods are called, without executing the actual method logic.

## 7. What are Mockito ArgumentMatchers?
- ArgumentMatchers are used in Mockito to provide flexibility when stubbing or verifying method calls. They allow matching method arguments, such as `ArgumentMatchers.any()` for any type of argument, or more specific matchers like `ArgumentMatchers.eq()` for exact values.

## 8. What are Hamcrest Matchers?
- Hamcrest is a library for writing matcher rules to assert test outcomes in a readable way. Common matchers include `assertThat(actual, is(expected))`, where you can easily express test expectations in a more natural, human-readable form.

## 9. Compare @Spy and @Mock.
- **@Spy**: Allows partial mocking where real methods are still called unless explicitly mocked.
- **@Mock**: Replaces the actual object with a mock object that has no real behavior unless defined by stubbing.

## 10. Explain Assertions.
- Assertions are used to validate that the actual results of a test match the expected results. Common assertions include:
  - `assertEquals(expected, actual)`
  - `assertTrue(condition)`
  - `assertNull(object)`

## 11. Add unit tests for CommentServiceImpl under Redbook.
1. Enrich the logic inside `CommentServiceImpl` methods by adding `if-else` conditions.
2. Replace `modelMapper` with the custom method `commentServiceMapperUtil`.
3. Ensure method and branch coverage is as close to 100% as possible.
