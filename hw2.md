1.
[jar](https://mvnrepository.com/artifact/ch.qos.logback/logback-core/1.5.8)
[war](https://mvnrepository.com/artifact/org.atmosphere.client/javascript/4.0.0)
pom
[aar](https://mvnrepository.com/artifact/androidx.appcompat/appcompat/1.7.0)

2. Jar vs War vs Pom
A JAR file is the most common type of Maven dependency. It typically contains compiled Java bytecode, associated metadata, and resources like images, property files, etc.It is used for Java libraries that are included as dependencies in other projects. When you add a JAR dependency, you are including the compiled classes and resources of that JAR into your project.
A WAR file is used for packaging web applications in Java, including servlets, JSPs, and other web-related resources like HTML, JavaScript, CSS, and XML configuration files.
It is used when developing Java EE web applications that need to be deployed to a servlet container like Apache Tomcat, Jetty, or any other web server supporting Java-based web applications.
A POM file (with .pom extension) is used to manage dependencies, plugins, and other project configurations. It does not contain any compiled code or resources like JAR or WAR files. Instead, it acts as a parent project or dependency aggregator. It is used when defining parent projects or BOM (Bill of Materials) files, which can manage versions of dependencies and configure shared plugins across multiple child projects.

3. Create a project and added the dependencies
No error encountered.
Project is attached.

4. Build the project and install it to local Maven repo
No error encountered.

5. 
6. List Maven life cycles in order, compare them.
Maven has three built-in life cycles:

default (also called build lifecycle): This is the main lifecycle that handles the projectâ€™s build process.
clean lifecycle: This lifecycle is used to clean the project and remove files generated by the previous build.
site lifecycle: This lifecycle is used to generate the project's documentation.
Each lifecycle is divided into phases, and each phase has a specific task. Here's the default lifecycle with key phases:

validate: Validate the project is correct and all necessary information is available.
compile: Compile the source code of the project.
test: Run unit tests using a testing framework.
package: Package the compiled code into a JAR/WAR file.
verify: Run any checks on the results of integration tests.
install: Install the package into the local repository, making it available for other projects on the same machine.
deploy: Deploy the final package to a remote repository for sharing with other developers.

7. Explain git merge vs git rebase
Both git merge and git rebase are used to combine changes from one branch into another, but they work differently.

git merge: Combines two branches by creating a new merge commit that has two parent commits (one from each branch). This retains the original history of both branches and preserves the context in which the changes were made. The history will show where the branches diverged and then came together.

git rebase: Reapplies your changes from the feature branch on top of another branch. This rewrites the commit history, making it appear as if all changes were made sequentially, without branching.

8. Explain Trunk-based development git branching strategy.
Trunk-based development is a Git branching strategy where all developers work on a single branch called the "trunk" (often main or master) and continuously integrate their changes into this trunk.

9. Explain git reset options.
git reset is used to undo changes in your working directory and the staging area. There are three primary modes of git reset, which determine the scope of the changes that are reset:

--soft: Moves the HEAD pointer to the specified commit, but leaves the working directory and the index (staging area) unchanged. This means the changes remain staged, ready to commit again.

Use when you want to undo a commit but keep your changes staged.
--mixed (default): Moves the HEAD pointer to the specified commit and unstages any changes that were previously committed, but leaves the working directory unchanged.

Use when you want to uncommit changes but keep them in your working directory (they will no longer be staged).
--hard: Moves the HEAD pointer to the specified commit and completely resets the working directory and the index to match that commit. This will permanently delete any changes that were not committed.